---
title: "Elezioni Emilia-Romagna"
author: "Luca Fornasari"
date: "`r Sys.Date()`"
format: 
  html:
    self-contained: true
---

Questo report contiene i risultati di una simulazione delle prossime elezioni
del Consiglio della Regione Emilia-Romagna, ottenuti
partendo dai risultati delle elezioni europee 2024.
Vengono eseguite 1000 simulazioni, in ciascuna di esse le percentuali che ciascuna
lista ha preso alle elezioni europee in ciascuna provincia 
vengono aumentate o diminuite casualmente, in modo che la variabilità dei
risultati ottenuti sia la stessa che è stata registrata nelle passate elezioni
per quella lista. Ad esempio, se il PD in passato è oscillato tra il 25% e il 35%,
le percentuali del PD simulate oscilleranno tra 5 punti percentuali in più
e 5 punti percentuali in meno rispetto a quelle delle europee.

Per le liste che non erano presenti nelle passate elezioni la variabilità
è stata calcolata partendo dalle liste più affini.

Avverto che ho fatto questa simulazione per curiosità e non per lavoro, e che
potrebbero essermi sfuggiti degli errori nel processo di
simulazione, i risultati vanno dunque presi senza alcuna garanzia di
accuratezza.

Segnalazioni, richieste e suggerimenti a <fornaeffe@gmail.com> o sul repository
<https://github.com/fornaeffe/elezioni-EMR>.

```{r setup}
#| include: false
knitr::opts_chunk$set(echo = FALSE)

library(data.table)
library(stringr)
library(readxl)
library(parallel)
library(kableExtra)
library(zoo)

```

```{r distribuzione voti}
#| include: false
#| cache: true
#### Importazione dati ####

##### Base dati #####

# TODO usare una base dati più aggiornata, soprattutto per quanto riguarda
# la popolazione

importa_dati <- function() {
  base_dati <- read.csv2(
    "dati/BaseDati_Proposta_Commissione.csv",
    fileEncoding = "utf-8",
    na.strings = ""
  )
  
  
  # Rinomino le colonne per coerenza con le altre fonti
  names(base_dati)[names(base_dati) == "DEN_PRO_CM20"] <- "PROVINCIA"
  names(base_dati)[names(base_dati) == "DEN_COM20"] <- "COMUNE"
  
  # Trasformo in maiuscolo per coerenza
  base_dati$PROVINCIA <- toupper(base_dati$PROVINCIA)
  base_dati$COMUNE <- toupper(base_dati$COMUNE)
  
  # Ottengo l'elenco delle province
  province <- aggregate(
    POP_2011 ~ PROVINCIA,
    base_dati,
    sum
  )
  
  # Ottengo l'elenco dei comuni
  comuni <- unique(base_dati[, c("PROVINCIA", "COMUNE")])
  
  ##### Politiche 2018 #####
  
  # Carico i dati delle elezioni politiche del 2018
  camera_2018 <- read.csv2(
    "dati/2018/camera-20180304_2.txt",
    fileEncoding = "utf-8"
  )
  
  # Collego ciascun collegio uninominale alla provincia di riferimento
  # TODO: sarebbe più opportuno svolgere questa operazione comune per comune,
  # ma ci sono troppe differenze tra i nomi dei comuni nei dati delle politiche
  # 2018 e i nomi dei comuni nella base dati
  camera_2018$COMUNE_COLLEGIO <- str_remove(camera_2018$COLLEGIOUNINOMINALE, "\\A[0-9]{2} (- )?")
  camera_2018$COMUNE_COLLEGIO <- str_remove(camera_2018$COMUNE_COLLEGIO, " - .*\\Z")
  camera_2018$COMUNE_COLLEGIO <- str_remove(camera_2018$COMUNE_COLLEGIO, " AREA STATISTICA .*\\Z")
  
  camera_2018 <- merge(
    camera_2018,
    comuni,
    by.x = "COMUNE_COLLEGIO",
    by.y = "COMUNE",
    all.x = TRUE
  )
  
  camera_2018$PROVINCIA[camera_2018$COMUNE_COLLEGIO == ""] <- "AOSTA"
  camera_2018$PROVINCIA[camera_2018$COMUNE_COLLEGIO == "BOLZANO/BOZEN"] <- "BOLZANO"
  camera_2018$PROVINCIA[camera_2018$COMUNE_COLLEGIO == "BRESSANONE/BRIXEN"] <- "BOLZANO"
  camera_2018$PROVINCIA[camera_2018$COMUNE_COLLEGIO == "CANT+"] <- "COMO"
  camera_2018$PROVINCIA[camera_2018$COMUNE_COLLEGIO == "CORIGLIANO CALABRO"] <- "COSENZA"
  camera_2018$PROVINCIA[camera_2018$COMUNE_COLLEGIO == "FORL¦"] <- "FORLI'-CESENA"
  camera_2018$PROVINCIA[camera_2018$COMUNE_COLLEGIO == "MERANO/MERAN"] <- "BOLZANO"
  camera_2018$PROVINCIA[camera_2018$COMUNE_COLLEGIO == "NARDÊ"] <- "LECCE"
  camera_2018$PROVINCIA[camera_2018$COMUNE_COLLEGIO == "PATERNÊ"] <- "CATANIA"
  camera_2018$PROVINCIA[camera_2018$COMUNE_COLLEGIO == "SAN DONA' DI PIAVE"] <- "VENEZIA"
  
  # Checks
  # TO DO: trasformare in un controllo che innesca un errore
  setdiff(unique(camera_2018$PROVINCIA), province$PROVINCIA)
  sum(is.na(camera_2018$PROVINCIA))
  
  
  ##### Politiche 2022 #######
  
  # Carico l'anagrafica dei comuni e la formatto coerentemente con gli altri dati
  anagrafica_comuni <- read.csv("dati/2022/camera-italia-comune_anagrafica.csv")
  anagrafica_comuni <- anagrafica_comuni[, c(
    "codice",
    "desc_com",
    "desc_prov",
    "desc_circ",
    "ele_t",
    "vot_t"
  )]
  names(anagrafica_comuni) <- c(
    "codice",
    "COMUNE",
    "PROVINCIA",
    "CIRCOSCRIZIONE",
    "ELETTORI",
    "VOTANTI"
  )
  
  # Carico i dati elettorali per comune
  camera_2022 <- read.csv("dati/2022/camera-italia-comune.csv")
  
  # Aggiungo i dati relativi ai comuni
  camera_2022 <- merge(
    camera_2022,
    anagrafica_comuni
  )
  
  # Rinomino le colonne
  names(camera_2022)[names(camera_2022) == "desc_lis"] <- "LISTA"
  names(camera_2022)[names(camera_2022) == "voti"] <- "VOTI_LISTA"
  names(camera_2022)[names(camera_2022) == "cogn"] <- "COGNOME"
  names(camera_2022)[names(camera_2022) == "nome"] <- "NOME"
  
  # Rinomino alcune province, per coerenza
  camera_2022$PROVINCIA[camera_2022$PROVINCIA == "REGGIO NELL' EMILIA"] <- "REGGIO NELL'EMILIA"
  camera_2022$PROVINCIA[camera_2022$PROVINCIA == "MASSA-CARRARA"] <- "MASSA CARRARA"
  
  
  # Distribuisco i voti al solo candidato proporzionalmente tra le liste
  # che lo sostengono
  camera_2022 <- merge(
    camera_2022,
    aggregate(
      VOTI_LISTA ~
        codice +
        COGNOME +
        NOME,
      camera_2022,
      sum
    ),
    by = c("codice", "COGNOME", "NOME"),
    suffixes = c("", "_TOT")
  )
  
  camera_2022$VOTI_LISTA <- 
    camera_2022$VOTI_LISTA +
    camera_2022$voti_solo_can * 
    camera_2022$VOTI_LISTA / camera_2022$VOTI_LISTA_TOT
  
  
  camera_2022 <- camera_2022[,c(
    "CIRCOSCRIZIONE",
    "PROVINCIA",
    "COMUNE",
    "ELETTORI",
    "VOTANTI",
    "COGNOME",
    "NOME",
    "LISTA",
    "VOTI_LISTA"
  )]
  
  
  
  ###### Trovo la regione #######
  
  camera_2018$REGIONE <- str_remove(camera_2018$CIRCOSCRIZIONE, " [0-9]\\Z")
  camera_2018$REGIONE <- str_remove(camera_2018$REGIONE, "/.*")
  camera_2018$ELEZIONE <- "camera_2018"
  
  camera_2022$REGIONE <- str_remove(camera_2022$CIRCOSCRIZIONE, " [0-9]\\Z")
  camera_2022$REGIONE <- str_remove(camera_2022$REGIONE, "/.*")
  camera_2022$ELEZIONE <- "camera_2022"
  
  ##### Amministrative #####
  
  lista_files <- list.files("dati/eur_reg")
  
  lista_dataframes <- lapply(
    paste0("dati/eur_reg/", lista_files),
    read.csv2,
    fileEncoding = "utf-8"
  )
  
  lista_dataframes <- mapply(
    function(df, nome_file) {
      names(df) <- toupper(names(df))
      if (is.null(df$COGNOME)) df$COGNOME <- NA
      if (is.null(df$NOME)) df$NOME <- NA
      names(df)[names(df) == "VOTILISTA"] <- "VOTI_LISTA"
      df <- df[,c(
        "REGIONE",
        "PROVINCIA",
        "COMUNE",
        "ELETTORI",
        "VOTANTI",
        "COGNOME",
        "NOME",
        "LISTA",
        "VOTI_LISTA"
      )]
      df$ELEZIONE <- nome_file
      df
    },
    df = lista_dataframes,
    nome_file = lista_files,
    SIMPLIFY = FALSE
  )
  
  amministrative <- rbindlist(lista_dataframes)
  lista_dataframes <- NULL
  
  # Rinomino alcune province
  amministrative$PROVINCIA[amministrative$PROVINCIA == "REGGIO NELL' EMILIA"] <- "REGGIO NELL'EMILIA"
  amministrative$PROVINCIA[amministrative$PROVINCIA == "MASSA-CARRARA"] <- "MASSA CARRARA"
  
  # Checks
  # TO DO: trasformare in un controllo che innesca un errore
  setdiff(unique(amministrative$PROVINCIA), province$PROVINCIA)
  
  
  ##### Unisco i dati #####
  
  comuni_liste_elezioni <- rbindlist(
    lapply(
      list(
        amministrative,
        camera_2018,
        camera_2022
      ),
      function(df) df[, c(
        "REGIONE",
        "PROVINCIA",
        "COMUNE",
        "ELETTORI",
        "VOTANTI",
        "LISTA",
        "VOTI_LISTA",
        "ELEZIONE"
      )]
    )
  )
  
  
  ###### Calcolo astensione ######
  
  calcola_astensione <- function(df) {
    astensione <- aggregate(
      VOTI_LISTA ~
        REGIONE +
        PROVINCIA +
        COMUNE +
        ELETTORI +
        VOTANTI +
        ELEZIONE,
      df,
      sum
    )
    
    astensione$LISTA <- "astensione"
    astensione$VOTI_LISTA <- astensione$ELETTORI - astensione$VOTI_LISTA
    
    astensione
  }
  
  comuni_liste_elezioni <- rbind(
    comuni_liste_elezioni,
    calcola_astensione(comuni_liste_elezioni)
  )
  
  province_liste_elezioni <- aggregate(
    VOTI_LISTA ~
      REGIONE +
      PROVINCIA +
      LISTA +
      ELEZIONE,
    comuni_liste_elezioni,
    sum
  )
  
  ##### Filtro (solo Emilia-Romagna) #####
  
  dati_precedenti <- province_liste_elezioni[province_liste_elezioni$REGIONE == "EMILIA-ROMAGNA", ]
  province <- province[province$PROVINCIA %in% dati_precedenti$PROVINCIA, ]
  
  ##### Dati Europee 2024 ####
  # Workaround finché non arriveranno gli open data
  
  e24_prov_liste <- read_xlsx("dati/liste.xlsx", "europee")
  
  e24_prov_liste$REGIONE = "EMILIA_ROMAGNA"
  e24_prov_liste$ELEZIONE = "europee2024"
  
  e24_prov <- aggregate(
    VOTI_LISTA ~
      REGIONE +
      PROVINCIA +
      ELEZIONE,
    e24_prov_liste,
    sum
  )
  
  e24_prov <- merge(
    e24_prov,
    read_xlsx("dati/popolazione.xlsx")
  )
  
  e24_prov$VOTI_LISTA <- e24_prov$ELETTORI - e24_prov$VOTI_LISTA
  e24_prov$LISTA <- "astensione"
  e24_prov$ELETTORI <- NULL
  
  dati_precedenti <- rbind(
    dati_precedenti,
    e24_prov_liste,
    e24_prov
  )
  
  return(list(province = province, dati_precedenti = dati_precedenti))
}

dati <- importa_dati()

prov_lista_elezione <- dati$dati_precedenti
province <- dati$province
```


```{r corrispondenza}
# Questo è servito per esportare i nomi delle liste
write.csv2(
  dati$prov_lista_elezione[!duplicated(dati$prov_lista_elezione$LISTA), ],
  "_output/liste_precedenti_elezioni.csv",
  fileEncoding = "utf-8"
)

##### Corrispondenza liste - aree #####

# Carico la tabella di corrispondenza tra liste e partiti, e la appiattisco

corrispondenza_liste <- as.data.table(read_xlsx("dati/corrispondenza_liste.xlsx"))
corrispondenza_liste[is.na(corrispondenza_liste)] <- 0

corrispondenza_liste <- melt(
  corrispondenza_liste,
  c("LISTA_ORIGINALE", "ELEZIONE"),
  variable.name = "LISTA",
  value.name = "FATTORE"
)

corrispondenza_liste <- corrispondenza_liste[corrispondenza_liste$FATTORE > 0, ]


# Unisco questa ai dati precedenti, e calcolo i voti per le nuove liste

names(prov_lista_elezione)[names(prov_lista_elezione) == "LISTA"] <- "LISTA_ORIGINALE"

corrispondenza_liste$ELEZIONE <- NULL

prov_lista_elezione <- merge(
  prov_lista_elezione,
  corrispondenza_liste,
  allow.cartesian = TRUE
)

prov_lista_elezione$VOTI_LISTA <- prov_lista_elezione$VOTI_LISTA * prov_lista_elezione$FATTORE

prov_lista_elezione <- aggregate(
  VOTI_LISTA ~ PROVINCIA + ELEZIONE + LISTA,
  prov_lista_elezione,
  sum
)
```


```{r serie storica}
#### Calcolo variabilità ####

elezioni <- unique(prov_lista_elezione$ELEZIONE)

date_elezioni <- sapply(elezioni, function(x) {
  if (x == "camera_2018") return(as.POSIXct("2018-03-04"))
  
  if (x == "camera_2022") return(as.POSIXct("2022-09-25"))
  
  if (x == "europee2024") return(as.POSIXct("2024-06-09"))
  
  return(as.POSIXct(substr(x, nchar(x)-11, nchar(x)-4), format = "%Y%m%d"))
})

df_elezioni <- data.frame(ELEZIONE = elezioni, DATA = as.POSIXct(date_elezioni))
df_elezioni$ordine <- rank(df_elezioni$DATA)


prov_lista_elezione <- merge(
  prov_lista_elezione,
  aggregate(
    VOTI_LISTA ~ PROVINCIA + ELEZIONE,
    prov_lista_elezione, 
    sum
  ),
  by = c("PROVINCIA", "ELEZIONE"),
  suffixes = c("", "_PROV")
)

prov_lista_elezione$PERCENTUALE <-
  prov_lista_elezione$VOTI_LISTA / prov_lista_elezione$VOTI_LISTA_PROV

prov_lista_elezione$LOG_P <- log(prov_lista_elezione$PERCENTUALE)


lista_elezione <- aggregate(
  VOTI_LISTA ~ LISTA + ELEZIONE,
  prov_lista_elezione,
  sum
)

lista_elezione <- merge(
  lista_elezione,
  aggregate(
    VOTI_LISTA ~ ELEZIONE,
    lista_elezione,
    sum
  ),
  by = "ELEZIONE",
  suffixes = c("", "_REG")
)

lista_elezione$PERCENTUALE <- 
  lista_elezione$VOTI_LISTA / lista_elezione$VOTI_LISTA_REG

lista_elezione$LOG_P <- log(lista_elezione$PERCENTUALE)



lista_elezione <- merge(
  lista_elezione,
  df_elezioni[, c("ELEZIONE", "ordine")]
)

# lista_elezione <- merge(
#   lista_elezione,
#   df_elezioni[, c("ELEZIONE", "DATA")]
# )
# 
# lista_elezione <- lista_elezione[order(lista_elezione$ordine),]
# plot(PERCENTUALE ~ DATA, data = lista_elezione, pch = "")
# tapply(lista_elezione, lista_elezione$LISTA, function(df) {
#   lines(PERCENTUALE ~ DATA, data = df)
# })
# 
# 
# plot(LOG_P ~ DATA, data = lista_elezione, pch = "")
# tapply(lista_elezione, lista_elezione$LISTA, function(df) {
#   lines(LOG_P ~ DATA, data = df)
# })


```


```{r sigma}
SIGMA_R <- tapply(lista_elezione, lista_elezione$LISTA, function(df) {
  ts <- zoo(df$LOG_P, df$ordine)
  return(sd(diff(ts)))
})

liste <- data.frame(
  LISTA = names(SIGMA_R),
  SIGMA_R = SIGMA_R
)

prov_lista_elezione <- merge(
  prov_lista_elezione,
  lista_elezione[, c("LISTA", "ELEZIONE", "LOG_P")],
  by = c("LISTA", "ELEZIONE"),
  suffixes = c("", "_REG")
)

prov_lista_elezione$DELTA <- 
  prov_lista_elezione$LOG_P - prov_lista_elezione$LOG_P_REG

prov_lista_elezione <- merge(
  prov_lista_elezione,
  df_elezioni[, c("ELEZIONE", "ordine")]
)

SIGMA_P <- tapply(prov_lista_elezione, prov_lista_elezione$LISTA, function(df) {
  sd(unlist(tapply(df, df$PROVINCIA, function(df) {
    ts <- zoo(df$DELTA, df$ordine)
    return(diff(ts))
  })))
})

stopifnot(all.equal(names(SIGMA_P), liste$LISTA))

liste$SIGMA_P <- SIGMA_P

liste$SIGMA_R[is.na(liste$SIGMA_R)] <- mean(liste$SIGMA_R, na.rm = TRUE)
liste$SIGMA_P[is.na(liste$SIGMA_P)] <- mean(liste$SIGMA_P, na.rm = TRUE)

# CAP!
liste$SIGMA_R[liste$SIGMA_R > 1] <- 1

# Scale
liste$SIGMA_R <- liste$SIGMA_R / 2

```

```{r dati}
#| include: false
#| cache: true

##### Carico liste regionali #####

liste_coal <- read_xlsx("dati/liste.xlsx")

stopifnot(setequal(liste$LISTA, c(liste_coal$LISTA, "astensione")))

liste <- merge(liste, liste_coal, all.x = TRUE)

liste <- merge(
  liste,
  lista_elezione[lista_elezione$ELEZIONE == "europee2024", c("LISTA", "LOG_P")]
)

prov_lista <- prov_lista_elezione[
  prov_lista_elezione$ELEZIONE == "europee2024",
  c("LISTA", "PROVINCIA", "DELTA", "VOTI_LISTA_PROV")
]

prov_lista <- merge(
  prov_lista,
  liste[, c("LISTA", "SIGMA_P")]
)

```

```{r simula}
#| include: false
#| cache: true

simula <- function(
    iterazioni = 200
) {
  
  iterazione <- function(
    iter = 1,
    liste,
    prov_lista,
    province
  ) {
    #### Simulazione percentuali regionali ####
    liste$LOG_P_ITER <- rnorm(
      liste$LOG_P,
      liste$LOG_P,
      liste$SIGMA_R
    )
    
    #### Simulazione percentuali per provincia ####
    prov_lista <- merge(
      prov_lista,
      liste[, c("LISTA", "LOG_P_ITER")]
    )
    
    names(prov_lista)[names(prov_lista) == "LOG_P_ITER"] <- "LOG_P_ITER_R"
    
    prov_lista$DELTA_ITER <- rnorm(
      prov_lista$DELTA,
      prov_lista$DELTA,
      prov_lista$SIGMA_P
    )
    
    prov_lista$LOG_P_ITER <- prov_lista$LOG_P_ITER_R + prov_lista$DELTA_ITER
    
    prov_lista$PERCENTUALE_ITER <- ave(
      prov_lista$LOG_P_ITER,
      prov_lista$PROVINCIA,
      FUN = function(x) exp(x) / sum(exp(x))
    )
    
    
    prov_lista$VOTI_LISTA_ITER <- prov_lista$VOTI_LISTA_PROV * prov_lista$PERCENTUALE_ITER
    
    scrutinio <- Scrutinio(
      prov_lista[, c(
        "PROVINCIA",
        "LISTA",
        "VOTI_LISTA_ITER"
      )],
      province,
      liste[, c(
        "COALIZIONE",
        "LISTA"
      )]
    )
    
    scrutinio$prov_lista <- merge(
      scrutinio$prov_lista,
      prov_lista[, c(
        "PROVINCIA",
        "LISTA",
        "VOTI_LISTA_ITER"
      )]
    )
    
    scrutinio$prov_lista <- merge(
      scrutinio$prov_lista,
      aggregate(
        VOTI_LISTA_ITER ~ PROVINCIA,
        scrutinio$prov_lista,
        sum
      ),
      by = "PROVINCIA",
      suffixes = c("", "_TOT")
    )
    
    scrutinio$prov_lista$PERCENTUALE <-
      scrutinio$prov_lista$VOTI_LISTA_ITER / 
      scrutinio$prov_lista$VOTI_LISTA_ITER_TOT
    
    scrutinio$liste <- merge(
      liste[, c(
        "COALIZIONE",
        "LISTA"
      )],
      aggregate(
        cbind(ELETTI, VOTI_LISTA_ITER) ~ LISTA,
        scrutinio$prov_lista,
        sum
      )
    )
    
    scrutinio$liste$PERCENTUALE <-
      scrutinio$liste$VOTI_LISTA_ITER / 
      sum(scrutinio$liste$VOTI_LISTA_ITER)
    
    scrutinio$coalizioni <- merge(
      scrutinio$coalizioni,
      aggregate(
        cbind(VOTI_LISTA_ITER, ELETTI) ~ COALIZIONE,
        scrutinio$liste,
        sum
      )
    )
    
    scrutinio$coalizioni$PERCENTUALE <-
      scrutinio$coalizioni$VOTI_LISTA_ITER / 
      sum(scrutinio$coalizioni$VOTI_LISTA_ITER)
    
    scrutinio$coalizioni$ELETTI_TOT <-
      scrutinio$coalizioni$PRESIDENTE +
      scrutinio$coalizioni$MIGLIOR_PERDENTE +
      scrutinio$coalizioni$ELETTI
    
    
    
    list(
      coalizioni = scrutinio$coalizioni,
      liste = scrutinio$liste,
      prov_lista = scrutinio$prov_lista
    )
    
  }
  
  cl <- makeCluster(parallel::detectCores())
  
  clusterEvalQ(
    cl,
    source("scrutinio.R")
  )
  
  lista_risultati <- parLapply(
    cl,
    seq_len(iterazioni),
    iterazione,
    liste = liste,
    prov_lista = prov_lista,
    province = province
  )
  
  stopCluster(cl)
  
  risultato <- list()
  
  risultato$coalizioni <-
    rbindlist(lapply(lista_risultati, function(l) l$coalizioni), idcol = "SIM")
  risultato$liste <-
    rbindlist(lapply(lista_risultati, function(l) l$liste), idcol = "SIM")
  risultato$prov_lista <-
    rbindlist(lapply(lista_risultati, function(l) l$prov_lista), idcol = "SIM")
  
  lista_risultati <- NULL
  
  risultato
}

risultato <- simula(1000)

```

## Risultati

```{r prep_grafici}
liste$COLORE[is.na(liste$COLORE)] <- "#DDDDDD"

risultato$liste <- merge(
  risultato$liste,
  liste[, c("LISTA", "COLORE")]
)

coalizioni <- liste[!duplicated(liste$COALIZIONE), c("COALIZIONE", "COLORE")]

risultato$coalizioni <- merge(
  risultato$coalizioni,
  coalizioni
)

risultato$liste$PERCENTUALE <- formattable::percent(risultato$liste$PERCENTUALE, 2)


```

### Percentuali per lista

```{r ris_per_partito}

par(mar=c(4, 12, 0.1, 0.1))

boxplot(
  PERCENTUALE * 100 ~ LISTA, 
  data = droplevels(risultato$liste[risultato$liste$COLORE != "#DDDDDD"]), 
  horizontal = TRUE, 
  las=1,
  xlab = "PERCENTUALE",
  ylab = NA,
  col = liste$COLORE
  )


```

### Coalizioni vincenti

```{r vincenti}

vittoria <- aggregate(
      PRESIDENTE ~ COALIZIONE,
      risultato$coalizioni,
      mean
    )

vittoria$PRESIDENTE <- formattable::percent(vittoria$PRESIDENTE, 0)


kbl(
    vittoria[vittoria$PRESIDENTE > 0,],
    col.names = c("COALIZIONE", "Prob."),
    caption = "Prob. di vittoria"
  ) %>%
    kable_minimal()


```


### Composizione media del Consiglio Regionale

```{r plot_parlamento}
library(ggplot2)
library(ggpol)
source("scrutinio.R")

disegna_parlamento <- function() {
  
  eletti <- aggregate(
    ELETTI ~ LISTA + COLORE + COALIZIONE,
    risultato$liste,
    mean
  )
  eletti$SEGGI <- Hare.Niemeyer(eletti$ELETTI, 48)
  eletti$Gruppo <- eletti$LISTA
  eletti <- eletti[order(eletti$COALIZIONE), ]
  
  pres <- aggregate(
    PRESIDENTE ~ COALIZIONE + COLORE,
    risultato$coalizioni,
    mean
  )
  pres$SEGGI <- 0
  pres$SEGGI[order(pres$PRESIDENTE, decreasing = TRUE)[1]] <- 1
  pres$Gruppo <- paste("Pres.", pres$COALIZIONE)
  pres$COLORE <- 
    adjustcolor(pres$COLORE, alpha.f = 0.5)
  
  miglior_perdente <- aggregate(
    MIGLIOR_PERDENTE ~ COALIZIONE + COLORE,
    risultato$coalizioni,
    mean
  )
  miglior_perdente$SEGGI <- 0
  miglior_perdente$SEGGI[order(miglior_perdente$MIGLIOR_PERDENTE, decreasing = TRUE)[1]] <- 1
  miglior_perdente$Gruppo <- paste("Cand. pres.", miglior_perdente$COALIZIONE)
  miglior_perdente$COLORE <- 
    adjustcolor(miglior_perdente$COLORE, alpha.f = 0.5)
  
  
  parlamento <- rbind(
    pres[, c("Gruppo", "SEGGI", "COLORE")],
    miglior_perdente[, c("Gruppo", "SEGGI", "COLORE")],
    eletti[, c("Gruppo", "SEGGI", "COLORE")]
  )
  
  
  parlamento <- parlamento[parlamento$SEGGI > 0, ]
  
  ggplot(parlamento) +
    geom_parliament(aes(seats = SEGGI, fill = Gruppo), color = "black") +
    scale_fill_manual(values = parlamento$COLORE, labels = paste(
      parlamento$Gruppo,
      "-",
      parlamento$SEGGI
    )) +
    coord_fixed() +
    theme_void()
}

disegna_parlamento()

```

### Probabilità di superare lo sbarramento

```{r}
superamento_soglia <- function() {
  
  soglie <- aggregate(
    ELETTI ~ LISTA,
    risultato$liste,
    function(x) mean(x > 0)
  )
  soglie <- soglie[soglie$LISTA %in% liste$LISTA[liste$COLORE != "#DDDDDD"],]
  soglie$SOGLIA <- formattable::percent(soglie$ELETTI, 0)
  kbl(
    soglie[, c("LISTA", "SOGLIA")],
    col.names = c("LISTA", "Prob."),
    caption = "Prob. di eleggere qualcuno"
  ) %>%
    kable_minimal()
}

superamento_soglia()

```

### Numero di seggi rispetto alle percentuali ottenute
```{r}
#| fig.width: 8
#| fig-height: 8
#| dpi: 100
par(mar = c(5, 4, 0, 0))
plot(ELETTI ~ PERCENTUALE, data = risultato$liste, col = COLORE)
legend(
  "bottomright", 
  legend = liste$LISTA[liste$LISTA != "astensione" & liste$COLORE != "#DDDDDD"], 
  col = liste$COLORE[liste$LISTA != "astensione" & liste$COLORE != "#DDDDDD"],
  pch = 1
)

```

```{r}
#| fig.width: 8
#| fig-height: 8
#| dpi: 100
par(mar = c(5, 4, 0, 0))
plot(ELETTI ~ PERCENTUALE, data = risultato$coalizioni, col = COLORE)
legend(
  "bottomright", 
  legend = coalizioni$COALIZIONE[coalizioni$COLORE != "#DDDDDD"], 
  col = coalizioni$COLORE[coalizioni$COLORE != "#DDDDDD"],
  pch = 1
)
```


### Probabilità di elezione per ciascuna posizione nelle province

```{r results='asis'}
disegna_tabella_prob <- function(lista) {
  lp <- risultato$prov_lista
  lp <- lp[lp$LISTA == lista, ]
  lp$ELETTI <- factor(lp$ELETTI, levels = 0:9)
  tbl <- table(lp$PROVINCIA, lp$ELETTI)
  tbl2 <- t(apply(
    tbl,
    1,
    function(x) {
      rev(cumsum(rev(x[2:10]))) / sum(x)
    }
  ))
  
  tbl2 <- as.data.frame(tbl2)
  for (i in 1:9) {
    tbl2[,i] <- formattable::percent(tbl2[, i], 1)
  }
  
  kb <- kbl(tbl2, caption = lista) %>%
    kable_minimal()
  
  valori_hsv <- rgb2hsv(col2rgb(liste$COLORE[liste$LISTA == lista]))
  
  for (i in 1:9) {
    kb <- column_spec(
      kb,
      i+1,
      background = hsv(
        valori_hsv["h", 1], 
        valori_hsv["s", 1], 
        valori_hsv["v", 1], 
        tbl2[,i]
      )
    )
  }
  kb
}


for (lista in liste$LISTA[liste$LISTA != "astensione" & liste$COLORE != "#DDDDDD"]) {
  print(disegna_tabella_prob(lista))
}

```


### Probabilità di elezione in base alla posizione nel listino


```{r plot_nmax}
#| fig.width: 8
#| fig-height: 8
#| dpi: 100

grafico_nmax <- function(lista, provincia = NA) {
  if (is.na(provincia)) {
    lp <- risultato$prov_lista
  } else {
    lp <- risultato$prov_lista[
      risultato$prov_lista$PROVINCIA == provincia,
    ]
  }
  
  nmax <- factor(
      lp$ELETTI[lp$LISTA == lista],
      levels = 0:9
    )
  # nmax[is.na(nmax)] <- 4
  colori <- c(hcl.colors(9), "#FFFFFF")
  spineplot(
    nmax ~ I(
      lp$PERCENTUALE[
        lp$LISTA == lista
      ] *100
    ),
    breaks = 12,
    col = colori,
    yaxlabels = NA,
    ylab = NA,
    xlab = "Percentuale nella provincia",
    main = paste0(
      lista,
      ifelse(is.na(provincia), "", paste0(" - ", provincia))
    )
  )
  
  legend(
    "topleft",
    legend = levels(nmax)[-1],
    fill = rev(colori[-10]),
    title = "Posizione"
  )
}

grafico_nmax("ALLEANZA VERDI E SINISTRA")

```

```{r}
#| fig.width: 8
#| fig-height: 8
#| dpi: 100

grafico_nmax("ALLEANZA VERDI E SINISTRA", "PARMA")

```
